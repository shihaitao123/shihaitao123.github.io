<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML和CSS面试题(1)]]></title>
    <url>%2F2018%2F09%2F26%2FHTML%E5%92%8CCSS%E9%9D%A2%E8%AF%95%E9%A2%98(1)%2F</url>
    <content type="text"><![CDATA[1.浏览器的内核 IE：trident内核 Firefox：gecko内核 Safari：webkit内核 Opera：以前是presto内核，现已经改用Blink内核 Chrome：Blink(基于webkit，Google和Opera Software公共开发） 2.怪异模式和标准模式的区别 总体会有布局，样式解析和脚本执行三个方面的区别 3.div+css的布局较table布局有什么优点？ 改版的时候更方便，只需要改CSS文件 表现与结构分离 页面加载速度快、结构化清晰、页面显示简洁 易于优化(seo)搜索引擎更友好，排名更容易靠前 4.为什么利用多个域名来存储网站资源会更有效？ CDN缓存更方便 突破浏览器并发限制节约cookie带宽节约主域名的连接数，优化页面响应速度防止不必要的安全问题 5.src和href的区别 src用于替换当前元素 href用于在当前文档和引用资源之间建立连接 href(Hypertext Reference)指向网络资源所在位置 &lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;&gt; 浏览器会识别该文档为CSS文件，就会并行下载资源并且不会停止对当前文档的处理。这也是问什么使用link方式加载CSS，而不是使用@import方式。 6.网页制作用到的图片格式 png-8 png-24 jpeg gif svg (WebP) WebP格式：Google开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节约大量的服务器带宽资源和数据空间。 在质量相同的情况下，WebP图像的体积比JPEG格式图像小40% 7.微格式 微格式是一种让机器可读的语义化XHTML词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式。 优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示。(应用范例：豆瓣) 8.在CSS/JS代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次JS请求一般情况下有哪些地方会有缓存处理？ DNS缓存 CDN缓存 浏览器缓存 服务器缓存 9.有哪些方法优化图片的加载 图片懒加载：]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2018%2F09%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[##冒泡排序 它是一种比较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾。采用相同的办法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止。 冒泡排序 * * 冒泡排序 * * 参数说明： * a -- 待排序的数组 * n -- 数组的长度 */ void bubble_sort1(int a[], int n) { int i,j; for (i=n-1; i&gt;0; i--) { // 将a[0...i]中最大的数据放在末尾 for (j=0; j&lt;i; j++) { if (a[j] &gt; a[j+1]) swap(a[j], a[j+1]); } } } 改进：对冒泡排序进行优化，使它效率更高：添加一个标记，如果一趟遍历中发生了交换，则标记为true，否则为false。如果某一趟没有发生交换，说明排序已经完成。 /* * 冒泡排序(改进版) * * 参数说明： * a -- 待排序的数组 * n -- 数组的长度 */ void bubble_sort2(int a[], int n) { int i,j; int flag; // 标记 for (i=n-1; i&gt;0; i--) { flag = 0; // 初始化标记为0 // 将a[0...i]中最大的数据放在末尾 for (j=0; j&lt;i; j++) { if (a[j] &gt; a[j+1]) { swap(a[j], a[j+1]); flag = 1; // 若发生交换，则设标记为1 } } if (flag==0) break; // 若没发生交换，则说明数列已有序。 } } ##冒泡排序的时间复杂度和稳定性 假设数列中有N个数，遍历一趟的时间复杂度是O(N),需要遍历N-1次，所以时间复杂度为O(N^2)。 冒泡排序是稳定的。 算法稳定性：假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！ ##完整程序： #include &lt;stdio.h&gt; // 数组长度 #define LENGTH(array) ( (sizeof(array)) / (sizeof(array[0])) ) // 交互数值 #define swap(a,b) (a^=b,b^=a,a^=b) /* * 冒泡排序 * * 参数说明： * a -- 待排序的数组 * n -- 数组的长度 */ void bubble_sort1(int a[], int n) { int i,j; for (i=n-1; i&gt;0; i--) { // 将a[0...i]中最大的数据放在末尾 for (j=0; j&lt;i; j++) { if (a[j] &gt; a[j+1]) swap(a[j], a[j+1]); } } } /* * 冒泡排序(改进版) * * 参数说明： * a -- 待排序的数组 * n -- 数组的长度 */ void bubble_sort2(int a[], int n) { int i,j; int flag; // 标记 for (i=n-1; i&gt;0; i--) { flag = 0; // 初始化标记为0 // 将a[0...i]中最大的数据放在末尾 for (j=0; j&lt;i; j++) { if (a[j] &gt; a[j+1]) { swap(a[j], a[j+1]); flag = 1; // 若发生交换，则设标记为1 } } if (flag==0) break; // 若没发生交换，则说明数列已有序。 } } void main() { int i; int a[] = {20,40,30,10,60,50}; int ilen = LENGTH(a); printf(&quot;before sort:&quot;); for (i=0; i&lt;ilen; i++) printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); bubble_sort1(a, ilen); //bubble_sort2(a, ilen); printf(&quot;after sort:&quot;); for (i=0; i&lt;ilen; i++) printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); } 本文链接：数据结构与算法]]></content>
      <categories>
        <category>DS &amp;&amp; A</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS面试题(1)]]></title>
    <url>%2F2018%2F09%2F25%2FCSS%E9%9D%A2%E8%AF%95%E9%A2%98(1)%2F</url>
    <content type="text"><![CDATA[CSS 中类 (classes) 和 ID 的区别。 **请问 &quot;resetting&quot; 和 &quot;normalizing&quot; CSS 之间的区别？你会如何选择，为什么？** **请解释浮动 (Floats) 及其工作原理。** **描述z-index和叠加上下文是如何形成的。** **请描述 BFC(Block Formatting Context) 及其如何工作。** **列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。** **请解释 CSS sprites，以及你要如何在页面或网站中实现它。** **你最喜欢的图片替换方法是什么，你如何选择使用。** **你会如何解决特定浏览器的样式问题？** **如何为有功能限制的浏览器提供网页？ ** **你会使用哪些技术和处理方法？** **有哪些的隐藏内容的方法 (如果同时还要保证屏幕阅读器可用呢)？** **你用过栅格系统 (grid system) 吗？如果使用过，你最喜欢哪种？** **你用过媒体查询，或针对移动端的布局/CSS 吗？** **你熟悉 SVG 样式的书写吗？** **如何优化网页的打印样式？** **在书写高效 CSS 时会有哪些问题需要考虑？** **使用 CSS 预处理器的优缺点有哪些？ ** **请描述你曾经使用过的 CSS 预处理器的优缺点。** **如果设计中使用了非标准的字体，你该如何去实现？** **请解释浏览器是如何判断元素是否匹配某个 CSS 选择器？** **请描述伪元素 (pseudo-elements) 及其用途。** **请解释你对盒模型的理解，以及如何在 CSS 中告诉浏览器使用不同的盒模型来渲染你的布局。** **请解释 * { box-sizing: border-box; } 的作用, 并且说明使用它有什么好处？** **请罗列出你所知道的 display 属性的全部值** **请解释 inline 和 inline-block 的区别？** **请解释 relative、fixed、absolute 和 static 元素的区别** **CSS 中字母 &apos;C&apos; 的意思是叠层 (Cascading)。请问在确定样式的过程中优先级是如何决定的 (请举例)？如何有效使用此系统？** **你在开发或生产环境中使用过哪些 CSS 框架？你觉得应该如何改善他们？** **请问你有尝试过 CSS Flexbox 或者 Grid 标准规格吗？** **为什么响应式设计 (responsive design) 和自适应设计 (adaptive design) 不同？** **你有兼容 retina 屏幕的经历吗？如果有，在什么地方使用了何种技术？** **请问为何要使用 translate() 而非 absolute positioning，或反之的理由？为什么？**]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML面试题(1)]]></title>
    <url>%2F2018%2F09%2F24%2FHTML%E9%9D%A2%E8%AF%95%E9%A2%98(1)%2F</url>
    <content type="text"><![CDATA[1.doctype(文档类型) 的作用是什么？ 声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式。 document.compatMode： BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。 CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。 这个属性会被浏览器识别并使用，但是如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat， 浏览器按照自己的方式解析渲染页面，那么，在不同的浏览器就会显示不同的样式。如果你的页面添加了&lt;!DOCTYPE html&gt;那么，那么就等同于开启了标准模式,那么浏览器就得老老实实的按照W3C的标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了。 2.浏览器标准模式 (standards mode) 、几乎标准模式（almost standards mode）和怪异模式 (quirks mode) 之间的区别是什么？ 所谓的标准模式是指，浏览器按W3C标准解析执行代码；怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。浏览器解析时到底使用标准模式还是怪异模式，与你网页中的DTD声明直接相关，DTD声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相应的方式加载网页并显示，忽略DTD声明,将使网页进入怪异模式(quirks mode)。 几乎标准模式（almost standards mode）是Firefox1+的设定的，类似于标准模式 判断浏览器模式: js方法 alert(window.top.document.compatMode) //BackCompat 怪异模式 //CSS1Compat 标准模式 jquery方法 alert($.boxModel) alert($.support.boxModel) 3.HTML 和 XHTML 有什么区别？ HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言，看起来与HTML有些相象，只有一些小的但重要的区别，XHTML就是一个扮演着类似HTML的角色的XML，所以，本质上说，XHTML是一个过渡技术，结合了XML(有几分)的强大功能及HTML(大多数)的简单特性。HTML 和 XHTML 的区别简单来说，XHTML 可以认为是 XML 版本的 HTML，为符合 XML 要求，XHTML 语法上要求更严谨些。以下是 XHTML 相对 HTML 的几大区别： XHTML 要求正确嵌套 XHTML 所有元素必须关闭 XHTML 区分大小写 XHTML 属性值要用双引号 XHTML 用 id 属性代替 name 属性 XHTML 特殊字符的处理 4.如果页面使用 ‘application/xhtml+xml’ 会有什么问题吗？ 使用xhtml,页面结构中必须包含head标签,并且每个标签结构都要关闭,包括空标签。所有标签都要小写。使用了’application/xhtml+xml’之后,部分老浏览器不会支持 5.如果网页内容需要支持多语言，你会怎么做？ 采用统一编码UTF-8方式编码 应用字符集的选择，对提供了多语言版本的网站来说，Unicode字符集应该是最理想的选择。它是一种双字节编码机制的字符集，不管是东方文字还是西方文字，在Unicode中一律用两个字节来表示，因而至少可以定义65536个不同的字符，几乎可以涵盖世界上目前所有通用的语言的每一种字符。 所以在设计和开发多语言网站时，一定要注意先把非中文页面的字符集定义为“utf-8”格式，即：这一步非常重要，原因在于若等页面做好之后再更改字符集设置，可说是一件非常非常吃力不讨好的工作，有时候甚至可能需要从头再来，重新输入网站的文字内容。 6.在设计和开发多语言网站时，有哪些问题你必须要考虑？ 在 HTML 中使用lang属性。 引导用户切换到自己的母语——让用户能够轻松地切换到自己的国家或语言，而不用麻烦。 在图片中展示文本会阻碍网站规模增长——把文本放在图片中展示，仍然是一种非常流行的方式。这样做可以在所有终端上，都能显示出美观的非系统字体。然而，为了翻译图片中的文本，需要为每种语言单独创建对应的图片，这种做法很容易在图片数量不断增长的过程中失控。 限制词语或句子的长度——网页内容在使用其他语言表述时，文字长度会发生变化。设计时，需要警惕文字长度溢出布局的问题，最好不要使用受文字长度影响较大的设计。比如标题、标签、按钮的设计，往往很受文字长度影响，这些设计中的文字与正文或评论部分不同，一般不可以自由换行。 注意颜色的使用——颜色在不同的语言和文化中，意义和感受是不同的。设计时应该使用恰当的颜色。 日期和货币的格式化——日期在不同的国家和地区，会以不同的方式显示。比如美国的日期格式是“May 31, 2012”，而在欧洲部分地区，日期格式是“31 May 2012”。 不要使用连接的翻译字符串——不要做类似这样的事情，比如“今天的日期是”+具体日期。这样做可能会打乱其他语言的语序。替代方案是，为每种语言编写带变量替换的模版字符串。请看下面两个分别用英语和中文表示的句子：I will travel on {% date %}和{% date %} 我会出发。可以看到，语言的语法规则不同，变量的位置是不同的。 注意语言阅读的方向——在英语中，文字是从左向右阅读的；而在传统日语中，文字是从右向左阅读的。 1- 应用字符集的选择；所以对提供了多语言版本的网站来说，Unicode字符集应该是最理想的选择。它是一种双字节编码机制的字符集，不管是东方文字还是西方文字，在Unicode中一律用两个字节来表示，因而至少可以定义65536个不同的字符，几乎可以涵盖世界上目前所有通用的语言的每一种字符。 所以在设计和开发多语言网站时，一定要注意先把非中文页面的字符集定义为“utf-8”格式，即：这一步非常重要，原因在于若等页面做好之后再更改字符集设置，可说是一件非常非常吃力不讨好的工作，有时候甚至可能需要从头再来，重新输入网站的文字内容。 2- 语言书写习惯&amp;导航结构 ；有些国家的语言书写习惯是从右到左，例如许多中东地区所使用的阿拉伯语，波斯语和希伯来语等等。如果你的市场目标是这些语言的国家，那么在网站设计中就需要考虑这些特殊的语言书写习惯。而且如果你在网站导航结构设计中使用的是一个竖直导航栏，这时候就应该把它放在右边，而不是象我们习惯的那样放在左边了。 3- 数据库驱动型网站对一个数据库驱动型的网站，尤其是当客户可以留言并向数据库添加信息时，则应当考虑如何从技术上实现对不同语言数据信息的收集和检索。 4- 搜索引擎&amp;市场推广；最好的办法是找一个专业的网站推广公司来帮助进行市场调研。调研内容主要应包括：目标市场国家或地区对什么搜索引擎或门户网站的使用率最高? 一些主要的门户网站的用户真实查询率又是多少? 这一点尤为重要。就象我们常使用新浪、搜狐等大型国内门户网站，但一般更多是为了使用其邮件服务。而查询的话还是喜欢百度或Google一样，你需要了解在这些人们青睐有加的门户网站上，到底有多少人是奔查询而来的。充分的市场考察才能做到有的放矢，从而保证最丰厚的投资回报。 7.使用 data- 属性的好处是什么？ 通过data-可以自定义属性,可以通过HTMLElement.dataset获取这些属性的值,data-中-后接自定义属性的名字,例如data-url。实际开发中可以利用这一点在生成DOM结构时把数据储存在自定义属性中,通过一系列交互操作,可以再获得这些数据,而不用再去ajax去后台取得数据。 8.如果把 HTML5 看作做一个开放平台，那它的构建模块有哪些？ 标签及属性 地理位置 画布 视频 音频 拖放 微数据 应用缓存 Web存储 web workers 服务器发送事件 语义 - 提供更准确地描述内容。 连接 - 提供新的方式与服务器通信。 离线和存储 - 允许网页在本地存储数据并有效地离线运行。 多媒体 - 在 Open Web 中，视频和音频被视为一等公民（first-class citizens）。 2D/3D 图形和特效 - 提供更多种演示选项。 性能和集成 - 提供更快的访问速度和性能更好的计算机硬件。 设备访问 - 允许使用各种输入、输出设备。 外观 - 可以开发丰富的主题。 9.请描述 cookies、sessionStorage 和 localStorage 的区别。 1)sessionStorage和localStorage是web storage的两种储存方式,其中sessionStorage是会话级别储存,在浏览器或页面关闭时数据就会销毁,而localStorage是持久化的本地储存,不刻意去删除数据,数据是不会销毁的。以上这两种方式只是客户端的储存,不会涉及到服务器储存。与之相比,每次发送HTTP请求时会将cookie添加到Cookie头字段,发送给服务器。 2)在储存量方面也有差异,单个cookie保存的数据不能超过4K,而localStorage和sessionStorage一般有5-10M。 3)每个域名下cookie的个数会有限制,依据浏览器不同会有不同,而localStorage数量是无限制的。 10.请解释script、script async和script defer的区别。 &lt;script&gt;加载js文件会阻塞页面的渲染和交互,而&lt;script async&gt;和&lt;script defer&gt;都是异步加载js文件,期间不会产生阻塞,区别在于&lt;script async&gt;是加载完之后自动执行,&lt;script defer&gt;需要等到页面加载之后再执行。 三者之间的区别： &lt;script&gt; - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。 &lt;script async&gt; - 脚本的提取、执行的过程与HTML解析过程并行，脚本执行完毕可能在HTML解析完毕之前。当脚本与页面上其他脚本独立时，可以使用async，比如用作页面统计分析。 &lt;script defer&gt; - 脚本仅提取过程与HTML解析过程并行，脚本的执行将在HTML解析完毕后进行。如果有多个含defer的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。 11.为什么通常推荐将 CSS &lt;link&gt; 放置在 &lt;head&gt;&lt;/head&gt; 之间，而将 JS &lt;script&gt; 放置在 &lt;/body&gt; 之前？你知道有哪些例外吗？ 把&lt;link&gt;放在&lt;head&gt;中 把&lt;link&gt;标签放在&lt;head&gt;&lt;/head&gt;之间是规范要求的内容。此外，这种做法可以让页面逐步呈现， 提高了用户体验。将样式表放在文档底部附近，会使许多浏览器（包括Internet Explorer）不能 逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，重新绘制页面中的元素。这 种做法可以防止呈现给用户空白的页面或没有样式的内容。 把&lt;script&gt;标签恰好放在&lt;/body&gt;之前 脚本在下载和执行期间会阻止HTML解析。把&lt;script&gt;标签放在底部，保证HTML首先完成解析，将页面尽早呈现给用户。 例外情况是当你的脚本里包含document.write()时。但是现在，document.write()不推荐使用。同时，将&lt;script&gt;标签放在底部，意味着浏览器不能开始下载脚本，直到整个文档（document）被解析。也许，对此比较好的做法是，&lt;script&gt;使用defer属性，放在&lt;head&gt;中。 一般希望DOM还没加载必须需要先加载的js会放置在&lt; head&gt;中,有些加了defer、async的&lt; script&gt;也会放在&lt; head&gt;中。 12.什么是渐进式渲染 (progressive rendering)？ 渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。 在以前互联网带宽较小的时期，这种技术更为普遍。如今，移动终端的盛行，而移动网络往往不稳定，渐进式渲染在现代前端开发中仍然有用武之地。 一些举例： 图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript将加载并显示图像。 确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的CSS、脚本和内容，然后可以使用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容。 异步加载HTML片段——当页面通过后台渲染时，把HTML拆分，通过异步请求，分块发送给浏览器。更多相关细节可以在这里找到。 13.为什么在&lt;img&gt;标签中使用srcset属性？请描述浏览器遇到该属性后的处理过程。 因为需要设计响应式图片。我们可以使用两个新的属性——srcset 和 sizes——来提供更多额外的资源图像和提示，帮助浏览器选择正确的一个资源。 srcset 定义了我们允许浏览器选择的图像集，以及每个图像的大小。 sizes 定义了一组媒体条件（例如屏幕宽度）并且指明当某些媒体条件为真时，什么样的图片尺寸是最佳选择。 所以，有了这些属性，浏览器会： 1.查看设备宽度 2.检查sizes列表中哪个媒体条件是第一个为真 3.查看给予该媒体查询的槽大小 4.加载srcset列表中引用的最接近所选的槽大小的图像 14.你用过哪些不同的 HTML 模板语言？ 比如 Pug （以前叫 Jade）、 ERB、 Slim、 Handlebars、 Jinja、 Liquid 等等。在我看来，这些模版语言大多是相似的，都提供了用于展示数据的内容替换和过滤器的功能。大部分模版引擎都支持自定义过滤器，以展示自定义格式的内容。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>HTML面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[举例]]></title>
    <url>%2F2018%2F09%2F23%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E4%B8%80%E4%B8%AA%E4%B8%BE%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[在浏览器中输入 www.baidu.com 后执行的全部过程： 现在假设如果我们在客户端（客户端）浏览器中输入http://www.baidu.com,而baidu.com为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作： 1）客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。 2）在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 3）客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 4）客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。 本文链接： 1.计算机网络基础知识总结]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DHCP协议]]></title>
    <url>%2F2018%2F09%2F22%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-DHCP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。 本文链接： 1.计算机网络基础知识总结]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NAT协议]]></title>
    <url>%2F2018%2F09%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-NAT%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。 本文链接： 1.计算机网络基础知识总结]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2018%2F09%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-HTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP协议超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。 HTTP 协议包括哪些请求？ GET：请求读取由URL所标志的信息。 POST：给服务器添加信息（如注释）。 PUT：在给定的URL下存储一个文档。 DELETE：删除给定的URL所标志的资源。 HTTP 中， POST 与 GET 的区别 1）Get是从服务器上获取数据，Post是向服务器传送数据。 2）Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。 3）Get传送的数据量小，不能大于2KB；Post传送的数据量较大，一般被默认为不受限制。 4）根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。 I. 所谓 安全的 意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 II. 幂等 的意味着对同一URL的多个请求应该返回同样的结果。 HTTP工作原理HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。 Web服务器根据接收到的请求后，向客户端发送响应信息。 HTTP默认端口号为80，但是你也可以改为8080或者其他端口。 HTTP三点注意事项： HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP与HTTPS的区别HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 HTTPS和HTTP的区别主要如下： 1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 HTTPS的工作原理我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。 客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。 （1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。 （2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。 （3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。 （4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。 （5）Web服务器利用自己的私钥解密出会话密钥。 （6）Web服务器利用会话密钥加密与客户端之间的通信。 ！HTTPS加密 HTTPS的优点尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处： （1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； （2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 （3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 （4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 HTTPS的缺点虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的： （1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电； （2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响； （3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。 （5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。 http切换到HTTPS如果需要将网站从http切换到https到底该如何实现呢？ 这里需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：http://www.baidu.com改为https://www.baidu.com BTW，这里虽然将http切换为了https，还是建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。 本文链接： 1.HTTP 简介 2.计算机网络基础知识总结]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS协议]]></title>
    <url>%2F2018%2F09%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-DNS%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单地理解为将URL转换为IP地址。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。 本文链接： 1.计算机网络基础知识总结]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html简单计算器]]></title>
    <url>%2F2018%2F09%2F18%2Fhtml%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[html、css和javascript实现简单计算器。 实现功能： 当前日期 加减乘除 三角函数 取余取整 倒数阶乘 指数底数 相反数 幂运算 PI html结构四个表格： table： 日期的显示，数字的输入，清零，退格 table1： 三角函数等运算的显示 table2： 数字等的显示 table3: 运算符号的显示 js1.避免出现两个小数点: function dian () { var result=document.getElementById(&apos;result&apos;); if (result.value.indexOf(&apos;.&apos;)==-1) { result.value+=&apos;.&apos;; } } 2.清零，重新加载页面: function clean() { location.replace(location) } 3.数字的取整： Math.floor:向下取整，它返回的是小于或等于函数参数,并且与之最接近的整数 Math.ceil:向上取整，它返回的是大于或等于函数参数,并且与之最接近的整数 Math.round:在函数中是四舍五入 4.如何在网页显示一个具体的日期时间： window.onload=function(){ showTime(); } function showTime(){ var today=new Date(); var y=today.getFullYear(); var M=today.getMonth()+1; var d=today.getDate(); var h=today.getHours(); var m=today.getMinutes(); var s=today.getSeconds(); m=checkTime(m); s=checkTime(s); var week=today.getDay(); var w=new Array(&apos;星期天&apos;,&apos;星期一&apos;,&apos;星期二&apos;,&apos;星期三&apos;,&apos;星期四&apos;,&apos;星期五&apos;,&apos;星期六&apos;); for (var i=0;i&lt;w.length;i++) { document.getElementById(&apos;time&apos;).innerHTML=y+&apos;年&apos;+M+&apos;月&apos;+d+&apos;日&apos;+&apos;&lt;/br&gt;&apos;+h+&quot;:&quot;+m+&quot;:&quot;+s+&apos; &apos;+w[week]; } setTimeout(&apos;showTime()&apos;,500); } //数字小于10时，前面添加一个0 function checkTime(i){ if (i&lt;10) { i=&quot;0&quot; + i; } return i } 5.n!的实现： case &apos;n!&apos;: for (var i=1;i&lt;=result;i++) { if(sum==0){ sum=(sum+1)*i; }else{ sum=sum*i; } } break; 由于定义了sum=0的全局变量，所以在此处需要做一个判断，否则计算出的结果都将为0。 css设置渐变色: background-image:linear-gradient(to top right,#000,#fff);/设置按钮渐变色/ 实现界面： PS:sublime中文乱码的解决办法： 1）save with encoding utf-8 2) install package 本文链接： 1.https://c.runoob.com]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html注册登陆]]></title>
    <url>%2F2018%2F09%2F17%2Fhtml%E6%B3%A8%E5%86%8C%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[html、css和JavaScript实现简单的注册登陆功能。 账号： 6-12位 首字母不能为数字 只能包含字母和数字 密码： 6-12位 登陆界面html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;登陆&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;test.css&quot;&gt; &lt;script src=&quot;注册.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;body bgcolor=&quot;#F0F8FF&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;div id=&quot;title&quot;&gt;&lt;h2 align=&quot;center&quot;&gt;登陆&lt;/h2&gt;&lt;/div&gt; &lt;p class=&quot;input_box&quot;&gt; 账户：&lt;input id=&quot;uname&quot; type=&quot;text&quot; placeholder=&quot;请输入你的账户&quot;&gt; &lt;/p&gt; &lt;p class=&quot;input_box&quot;&gt; 密码：&lt;input id=&quot;upass&quot; type=&quot;text&quot; placeholder=&quot;请输入你的密码&quot;&gt; &lt;/p&gt; &lt;div id=&quot;error_box&quot;&gt;&lt;br&gt;&lt;/div&gt; &lt;div class=&quot;button&quot;&gt;&lt;button onclick=&quot;foLogin()&quot;&gt;登陆&lt;/button&gt;&lt;/div&gt; &lt;h4align=&quot;center&quot;&gt;&lt;a href=&quot;注册.html&quot;&gt;没有账号？点我注册&lt;/a&gt;&lt;/h4&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 登陆界面js function foLogin(){ var oUname=document.getElementById(&quot;Uname&quot;); var oError=document.getElementById(&quot;error_box&quot;); var oUpass=document.getElementById(&quot;Upass&quot;); var isError=true; oError.innerHTML=&quot;&lt;br&gt;&quot;; if(oUname.value.length&lt;6||oUname.value.length&gt;12){ oError.innerHTML=&quot;用户名要6-12位&quot;； isError=false; return; }else if(oUname.value.charCodeAt(0)&gt;=48&amp;&amp;（oUname.value.charCodeAt(0)&lt;=57)）{ oError.innerHTML=&quot;首位不能为数字&quot;； return; }else for (var i=0;i&lt;oUname.value.length;i++){ if((oUname.value.charCodeAt(i)&lt;48) || (oUname.value.charCodeAt(i)&gt;57)||(oUname.value.charCodeAt(i)&lt;58)||(oUname.value.charCodeAt(i)&gt;97)){ oError.innerHTML=&quot;只能为数字和密码&quot;； return； } } if(oUpass.value.length&lt;6||oUpass.value.length&gt;12){ oError.innerHTML=&quot;密码要6-12位&quot;； isError=false; return; } } 注册界面html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;注册&lt;/title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;test.css&quot;&gt; &lt;script src=&quot;登陆.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;body bgcolor=&quot;#F0F8FF&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;div id=&quot;title&quot;&gt;&lt;h2 align=&quot;center&quot;&gt;注册&lt;/h2&gt;&lt;/div&gt; &lt;p class=&quot;input_box&quot;&gt; 账户：&lt;input id=&quot;uname&quot; type=&quot;text&quot; placeholder=&quot;请输入你的账户&quot;&gt; &lt;/p&gt; &lt;p class=&quot;input_box&quot;&gt; 密码：&lt;input id=&quot;upass&quot; type=&quot;password&quot; placeholder=&quot;请设置你的密码&quot;&gt; &lt;/p&gt; &lt;p class=&quot;input_box&quot;&gt; 验证：&lt;input id=&quot;upass1&quot; type=&quot;password&quot; placeholder=&quot;请再次输入密码&quot;&gt; &lt;/p&gt; &lt;p class=&quot;input_box&quot;&gt; 邮箱：&lt;input id=&quot;邮箱&quot; type=&quot;text&quot; placeholder=&quot;请输入你的邮箱&quot;&gt; &lt;/p&gt; &lt;div id=&quot;error_box&quot;&gt;&lt;br&gt;&lt;/div&gt; &lt;div class=&quot;button&quot;&gt;&lt;button onclick=&quot;foLogin()&quot;&gt;立即注册&lt;/button&gt;&lt;/div&gt; &lt;h4 align=&quot;center&quot;&gt;&lt;a href=&quot;登陆.html&quot;&gt;已有账号请登录&lt;/a&gt;&lt;/h4&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 注册界面js function foLogin() { var oUname = document.getElementById(&quot;uname&quot;); var oError = document.getElementById(&quot;error_box&quot;); var oUpass = document.getElementById(&quot;upass&quot;); var oUpass1 = document.getElementById(&quot;upass1&quot;); var isError = true; oError.innerHTML = &quot;&lt;br&gt;&quot;; if (oUname.value.length &lt; 6 || oUname.value.length &gt; 12) { oError.innerHTML = &quot;用户名要6-12位&quot;; isError = false; return; }else if(oUname.value.charCodeAt(0)&gt;=48 &amp;&amp;(oUname.value.charCodeAt(0)&lt;=57)){ oError.innerHTML=&quot;首位不能为数字&quot;; return; }else for (var i=0;i&lt;oUname.value.length;i++){ if((oUname.value.charCodeAt(i)&lt;48)||(oUname.value.charCodeAt(i)&gt;57)&amp;&amp;(oUname.value.charCodeAt(i)&lt;58)&amp;&amp;(oUname.value.charCodeAt(i)&gt;97)){ oError.innerHTML=&quot;只能为数字和字母&quot;; return; } } if (oUpass.value.length &lt; 6 || oUpass.value.length &gt; 12) { oError.innerHTML = &quot;密码要6-12位&quot;; isError = false; return; }else if(oUname.value!=oUpass1.value) { oError.innerHTML = &quot;设置密码和验证密码不一致&quot;; return; } } css .box{ border: 1px solid #000000; height: 370px; width: 500px; float: left; margin: 50px; margin-left: 30%; } input{ align-self: center; height: 30px; widht:300px; } button{ font-size: 16px; width: 360px; height: 30px; align-self: center; margin-bottom: auto; background: #cccccc; margin-left: 15%; } 实现效果：]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP协议]]></title>
    <url>%2F2018%2F09%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-UDP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。 UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询—应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。 每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下： （1）源端口号； （2）目标端口号； （3）数据报长度； （4）校验值。 使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。 TCP 与 UDP 的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。 本文链接： 1.计算机网络基础知识总结]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由选择协议]]></title>
    <url>%2F2018%2F09%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[常见的路由选择协议有：RIP协议、OSPF协议。 RIP协议底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。 OSPF协议开放式最短路径优先(Open Shortest Path First)，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽和延迟。 本文链接： 1.计算机网络基础知识总结]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARP/RARP协议]]></title>
    <url>%2F2018%2F09%2F14%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-ARP%E5%92%8CRARP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[地址解析协议ARP(Address Resolution Protocol)：根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。 ARP工作流程举例： 主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01； 主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02； 当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程： （1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2;然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址 （2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求 （3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中 （4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A （5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了 逆地址解析协议RARP:功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。 RARP协议工作流程： （1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址 （2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址 （3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用 （4）如果不存在，RARP服务器对此不做任何的响应 （5）源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败 ARP/RARP具体解析过程A:当主机x和主机y在同一个网段中时： 首先主机x会查找自己的ARP缓存表，而这个表在windows系统中是使用ARP –A命令来进行查看的，如果存在主机y的ip地址与MAC地址之间的映射，那么可以直接使用这个关系中MAC地址对ip数据包进行封装。 如果在缓存表中没有找到这个关系，那么主机x以广播的方式发送一个ARP的请求报文，使得本网络中的每一个主机都能收到这个报文，这个ARP报文中，包含主机x的源ip地址和源MAC地址，以及目的ip地址，目的MAC地址中内容是全为f的广播地址。 主机y收到这样的报文后，将主机x发送的ARP的x的ip和MAC的对应关系存入自己的缓存中，同样将构造一个相应的ARP报文，将自己的MAC地址放到报文中，单播回主机x。 主机x收到这个相应报文后，将自己的缓存表中添加主机y的MAC地址与ip地址的对应关系，然后进行数据发送。 B.当主机x和主机y不在同一个网段中时： 如果主机x不知道网关的MAC地址，（也就是说在主机x的缓存表中没有网关的MAC地址映射）那么主机x先构造一个ARP的广播的请求报文，请求网关的MAC地址，进而获得网关的MAC与ip的对应关系。 如果主机x的缓存中已经有了网关的MAC地址与ip地址之间的关系了，那么将主机x发给主机y的ARP报文中的目的MAC地址的位置填写网关的MAC地址，发给网关。 如果在网关的ARP缓存表中有y的MAC地址，则网关直接将来自主机x的报文中的目的MAC地址字段填写主机y的MAC地址直接发给主机y。 如果在网关的缓存中不存在主机y的MAC地址，那么网关继续以广播的方式发送一个ARP的请求报文，请求主机y的MAC地址，然后，主机y相应单播回自己的MAC地址，其他主机不响应，这里的过程就是相同的网段中的ARP的建立的过程了。 通过以上两种方式，就建立起了ARP的解析的过程。 我们在学习ARP的时候要知道它存在的不足，也就是ARP的欺骗，网上的一些软件可以很容易做到ARP的欺骗，使得局域网中的网络通信收到严重的影响。我们先说明解决ARP欺骗的解决办法： 清除ARP缓存表 绑定静态的IP地址 而在企业中，一般的路由器都是企业级路由器，很少用到家用路由器，上边的两种方法可以用在电脑上，也可以用在家用的路由器上，但是企业路由器就行不通了，对企业路由器进行配置。作为一个企业的系统运维人员，我们在了解事故产生的原因的时候，更应该想到的是怎样去处理解决和防范这样的事故的产生： Arp检测功能，企业路由器如h3c的路由器可以启用arp的检测功能，检测用户的合法性，检测arp报文的有效性等。 可以使用路由器中的arp的限速功能，对大量arp报文进行限制。 在此我们说明，导致arp欺骗的原因，主要有以下三方面： 是欺骗网关的情况，黑客通过假冒主机A向网关发送ARP报文，使得网关错误的记录该主机A的合法的ARP映射，这样，使得外部网络数据无法到达内部网络。 是欺骗其他的主机，这种情况是向网络中的其他主机发送主机A的伪造的ARP报文，使得其他的主机不能访问主机A。 在arp的缓存表中存储的数据，即ip与mac的对应关系的条数是确定的，是有限度的，此时供给者构造大量的不同的源IP地址的arp报文，使得设备学习的arp的表项超出了最大的限制，最终使得合法的用户的arp报文不能有效的生成arp表项，导致不同通信。 本文链接： 1.计算机网络基础知识总结 2.ARP地址解析协议总结]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子网掩码与网络划分]]></title>
    <url>%2F2018%2F09%2F13%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%88%92%E5%88%86%2F</url>
    <content type="text"><![CDATA[子网掩码与网络划分子网掩码是一个应用于TCP/IP网络的32位二进制值，它可以屏蔽掉IP地址中的一部分，从而分离出IP地址中的网络部分和主机部分，基于子网掩码，管理员可以将网络进一步划分为若干子网。 在使用TCP/IP协议的两台计算机进行通信时，我们通过将本机的子网掩码与接收方主机的IP地址进行与运算，即可得到目标主机所在的网络号，又由于每台主机在配置TCP/IP协议时都设置了一个本机IP地址与子网掩码，所以可以知道本机所在的网络号。 通过比较两个网络号，就可以知道接收方主机是否在本网络上。如果网络号相同，表明接收方在本网络上，那么可以通过相关协议把数据包直接发送到目标主机；如果网络号不同，表明主机在远程网络上，那么数据包将会发送到本网络上的路由器，由路由器将数据包发送到其他网络，直至到目的地。在这个过程中，子网掩码是不可或缺的。 如何使用子网掩码得到网络/主机地址过程如下： 1.将IP地址与子网掩码转换成二进制 2.将二进制的IP地址与子网掩码做与运算，将答案转为十进制便得到网络地址 3.将二进制形式的子网掩码取反 4.将取反后的子网掩码与IP地址做与运算，将答案转为十进制便得到主机地址 假设有一个IP地址：192.68.0.1 子网掩码：255.255.255.0 化为二进制： IP地址：11000000.10101000.00000000.00000001 子网掩码：11111111.11111111.11111111.00000000 将二者做与运算：11000000.10101000.00000000.00000000 转为十进制：192.168.0.0，便是上面IP的网络地址 PS：由于上面的子网掩码为C类地址的默认子网掩码，便可直接看出网络地址为IP地址的前三部分，即前三个字节 ‘1’在做’与’运算时，不影响结果，’0’在做’与’运算时，将得到0，利用’与’的这个特性，当管理员设置子网掩码时，即将子网掩码上与网络地址所对应的位都设为’1’,其他位都设为’0’,那么当作’与’时，ip地址中的网络号将被保留到结果中，而主机号将被置0，这样就解析出了网络号，解析主机号也一样，只需先把子网掩码取’反’,在做’与’。 子网掩码的分类1）缺省子网掩码： 即未划分子网，对应的网络号的位都置1，主机号都置0。 A类网络缺省子网掩码：255.0.0.0 B类网络缺省子网掩码：255.255.0.0 C类网络缺省子网掩码：255.255.255.0 2）自定义子网掩码： 将一个网络划分为几个子网，需要每一段使用不同的网络号或子网号，实际上我们可以认为是将主机号分为两个部分：子网号、子网主机号。 形式如下：未做子网划分的ip地址：网络号＋主机号 做子网划分后的ip地址：网络号＋子网号＋子网主机号 也就是说ip地址在化分子网后，以前的主机号位置的一部分给了子网号，余下的是子网主机号。 子网编址技术子网划分也是靠子网掩码来实现的。 子网是指一个ip地址上生成的逻辑网络，它可以让一个网络地址跨越多个物理网络，即一个网络地址代表多个网络（很明显这样做可以节省ip地址）。呵呵，听起来是不是很蹊跷？一个网络就这样被莫名其妙的划分成了许多子网？那么这样做有什么用呢？ 我举个例子来跟你说吧：比如你是某个学校的网管，你的学校有四个处于不同物理位置的网络教室，每个网络教室25台机器，你的任务是给这些机器配置ip地址和子网掩码。你可能会觉得这再简单不过了，申请4个C类地址，每个教室一个，然后在一一配置不就搞定了。嗯，这样做理论上没错，但你有没有想到这样做很浪费，你一共浪费了(254-25)*4=916个ip地址，如果所有的网管都像你这样做，那么internet上的ip地址将会在极短的时间内枯竭，显然，你是不能这样做，你应该做子网划分。 子网划分说白了是这样一个事情：因为在划分了子网后，ip地址的网络号是不变的，因此在局域网外部看来，这里仍然只存在一个网络，即网络号所代表的那个网络；但在网络内部却是另外一个景象，因为我们每个子网的子网号是不同的，当用化分子网后的ip地址与子网掩码（注意，这里指的子网掩码已经不是缺省子网掩码了，而是自定义子网掩码，是管理员在经过计算后得出的）做’与’运算时，每个子网将得到不同的子网地址，从而实现了对网络的划分（得到了不同的地址，当然就能区别出各个子网了，有趣吧）。 子网编址技术，即子网划分将会有助于以下问题的解决： 1）巨大的网络地址管理耗费：如果你是一个A类网络的管理员，你一定会为管理数量庞大的主机而头痛的 2）路由器中的选路表的急剧膨胀：当路由器与其他路由器交换选路表时，互联网的负载是很高的，所需的计算量也很高 3）IP地址空间有限并终将枯竭：这是一个至关重要的问题，高速发展的internet,使原来的编址方法不能适应，而一些ip地址却不能被充分的利用，造成了浪费 因此，在配置局域网或其他网络时，根据需要划分子网是很重要的，有时也是必要的。现在，子网编址技术已经被绝大多数局域网所使用。 如何划分子网及确定子网掩码在动手划分之前，一定要考虑网络目前的需求和将来的需求计划。 划分子网主要从以下方面考虑: 1.网络中物理段的数量（即要划分的子网数量） 2.每个物理段的主机的数量 确定子网掩码的步骤： 第一步：确定物理网段的数量，并将其转换为二进制数，并确定位数n。如：你需要6个子网，6的二进制值为110，共3位,即n=3 第二步：按照你ip地址的类型写出其缺省子网掩码。如C类，则缺省子网掩码为11111111.11111111.11111111.00000000 第三步：将子网掩码中与主机号的前n位对应的位置置1，其余位置置0。若n=3且为 C类地址：则得到子网掩码为11111111.11111111.11111111.11100000化为十进制得到255.255.255.224 B类地址：则得到子网掩码为11111111.11111111.11100000.00000000化为十进制得到255.255.224.0 A类地址：则得到子网掩码为11111111.11100000.00000000.00000000化为十进制得到255.224.0.0 另：由于网络被划分为6个子网，占用了主机号的前3位，若是C类地址，则主机号只能用5位来表示主机号，因此每个子网内的主机数量＝（2的5次方）－2＝30，6个子网总共所能标识的主机数将小于254，这点请大家注意！ 解惑： 1.你可能有这样的疑问，比如在上面的例子里，6的二进制值为110，那么为什么要将子网掩码中与主机号的前n位对应的位置都置1，而不是用6的二进制110去替代前n位呢？ 答案是这样的：我们计算子网掩码的目的是什么？就是希望它在做’与’的时候能够解析出网络号，也就是说它与网络号所对应的位置都应该是1（当然包括与子网号所对应的位置），那么很显然，你写上110是不对的，如果你这么写，那么它的意义是主机号的前两位作为子网号，那么这样将最多划分2个子网（不明白没关系，下面有计算子网数量的方法),与我们当初所要划分的6个子网显然是不一致的。 2.细心的人可能会发现，划分4个子网，5个子网和6个子网的子网掩码是一样的，同为255.255.255.224，是不是错了呢？三个子网掩码应该不同呀？呵呵，是这样的，因为4，5，6的二进制值都是3为，因此在子网掩码中这三位都置1，划分是没有问题的，只是你的理解上有一点小小的问题，划分为4个子网，其实可以理解为划分为6个子网，但你只使用了其中的4个。比如你想划分8个子网，与划分14个子网所得到的子网掩码是一样的，都占用了4位作为子网号。 相关判断方法1）如何判断是否做了子网划分 这个问题很简单，如果它使用了缺省子网掩码，那么表示没有作子网划分；反之，则一定作了子网划分。 2）如何计算子网地址还是老办法，将ip地址与子网掩码的二进制形式做’与’，得到的结果即为子网地址。 3）如何计算主机地址这个也不用说了吧，先将子网掩码的二进制取’反’，再与ip地址做’与’。 4）如何计算子网数量 这个问题大家会常常提到，还是从子网掩码入手，主要有两个步骤： 观察子网掩码的二进制形式，确定作为子网号的位数n 子网数量为2的n次方－2（为什么减2） 举个例子来说，比如有这样一个子网掩码：255.255.255.224其二进制为：11111111.11111111.11111111.11100000 可见n=3,2的3次方为8，说明子网地址可能有如下8种情况： 000 001 010 011 100 101 110 111 但其中代表网络自身的000；代表广播地址的111是被保留的，所以要减2。 5）如何计算总主机数量，子网内主机数量 总主机数量＝子网数量×子网内主机数量 再用一个例子给大家说明，比如子网掩码为255.255.255.224 上面的讨论知道它最多可以划分6个子网，那么每个子网内最多有多少个主机呢？其实上面我已经给大家算过了，由于网络被划分为6个子网，占用了主机号的前3位，且是C类地址，则主机号只能用5位来表示主机号，因此子网内的主机数量＝（2的5次方）－2＝30 因此通过这个子网掩码我们可以算出这个网络最多可以标识6*30=180个主机（可见，在化分子网后，整个网络所能标识的主机数量将减少）。 6）计算ip地址范围 通过一个自定义子网掩码，我们可以得到这个网络所有可能的ip地址范围。具体步骤： 写出二进制子网地址 将子网地址化为十进制 计算子网所能容纳主机数 得出ip范围（起始地址：子网地址＋1；终止地址：子网地址＋主机数） 假设一个子网掩码为：255.255.255.224，可知其最多可以划分6个子网，子网内主机数为30，那么所有可能的ip地址及计算流程如下： 子网－－子网地址（二进制）－－－－－－－－子网地址－－－－－实际ip范围 1号－11001010.01110000.00001010.00100000－202.112.10.32－202.112.10.33-202.112.10.62 2号－11001010.01110000.00001010.01000000－202.112.10.64－202.112.10.65-202.112.10.94 3号－11001010.01110000.00001010.01100000－202.112.10.96－202.112.10.97-202.112.10.126 4号－11001010.01110000.00001010.10000000－202.112.10.128－202.112.10.129-202.112.10.158 5号－11001010.01110000.00001010.10100000－202.112.10.160－202.112.10.161-202.112.10.190 6号－11001010.01110000.00001010.11000000－202.112.10.192－202.112.10.193-202.112.10.222 本文参考地址: 1.子网掩码与子网划分]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP地址]]></title>
    <url>%2F2018%2F09%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-IP%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[IP地址IP地址是TCP/IP网络中用来唯一标识每台主机或设备的地址，IP地址由32位(共四个八位组)的二进制组成，IP地址分为两部分，左边网络编号部分用来标识主机所在的网络；右边部分用来标识主机本身。连接到同一网络的主机必须拥有相同的网络编号。 1）网络地址 IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。 2）广播地址 广播地址通常称为直接广播地址，是为了区分受限广播地址。广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。 3）组播地址 D类地址就是组播地址。 A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255 B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255 C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255 D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信） E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。 A类地址：0nnnnnnn.hhhhhhhh.hhhhhhhh.hhhhhhhh A类地址具有7位网络编号，因此可定义125个A类网络(网络编号不能是全0或全1)(127为环回地址)，每个网络可以拥有的主机数为16777214 十进制表示范围：1.0.0.1-126.255.255.254 B类地址：10nnnnnn.nnnnnnnn.hhhhhhhh.hhhhhhhh B类地址具有14位网络编号，因此可定义16382个B类网络 每个网络可以拥有的主机数为65534 十进制表示范围：128.0.0.1-191.255.255.254 C类地址：110nnnnn.nnnnnnnn.nnnnnnnn.hhhhhhhh C类地址具有21位网络编号，因此可定义2097152个C类地址 每个网络可以拥有的主机数为254 十进制表示范围：192.0.0.1-223.255.255.254 D类地址：1110xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx D类地址用于组播，前面4位1110引导，后面28位为组播地址ID。 十进制表示范围：224.0.0.0-239.255.255.255 E类地址：总是以1111四位引导 E类地址用于研究用 十进制表示范围：240- 特殊用途的IP地址4）255.255.255.255 该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。 对本机来说，这个地址指本网段内(同一广播域)的所有主机。如果翻译成人类的语言，应该是这样：“这个房间里的所有人都注意了！”这个地址不能被路由器转发。注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。 5）0.0.0.0 常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。 严格说来，0.0.0.0已经不是一个真正意义上的IP地址了。它表示的是这样一个集合：所有不清楚的主机和目的网络。这里的“不清楚”是指在本机的路由表里没有特定条目指明如何到达。对本机来说，它就是一个“收容所”，所有不认识的“三无”人员，一律送进去。如果你在网络设置中设置了缺省网关，那么Windows系统会自动产生一个目的地址为0.0.0.0的缺省路由。 6）回环地址 127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。用汉语表示，就是“我自己”。在Windows系统中，这个地址有一个别名“Localhost”。寻址这样一个地址，是不能把它发到网络接口的。除非出错，否则在传输介质上永远不应该出现目的地址为“127.0.0.1”的数据包。 7) 169.254.x.x 如果你的主机使用了DHCP功能自动获得一个IP地址，那么当你的DHCP服务器发生故障，或响应时间太长而超出了一个系统规定的时间，Wingdows系统会为你分配这样一个地址。如果你发现你的主机IP地址是一个诸如此类的地址，很不幸，十有八九是你的网络不能正常运行了。 8）A、B、C类私有地址 私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。它是不用申请可直接用于企业内部网的，这就是Private Address，Private Address不会被INTERNET上的任何路由器转发，欲接入INTERNET必须要通过NAT/PAT转换，以公有IP的形式接入。 A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255 B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255 C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255 对一台网络上的主机来说，它可以正常接收的合法目的网络地址有三种：本机的IP地址、广播地址以及组播地址。 本文链接： 1.计算机网络ip地址分类及含义 2.计算机网络基础知识总结]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI七层网络模型]]></title>
    <url>%2F2018%2F09%2F11%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-OSI%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[OSI七层网络模型网络标准化组织（ISO）在1978年提出了开放系统互联参考模型，即著名的OSI/RM模型(Open System interconnection/Reference Model)。它将计算机网络体系结构的通信协议分为七层，自下而上依次为： 物理层（Physics Layer） 数据链路层（Data Link Layer） 网络层(Network Layer) 传输层(Transport Layer) 会话层(Session Layer) 表示层(Presentation Layer) 应用层(Application Layer) 其中传输层完成数据传送服务，上面三层面向用户。 除了标准的OSI七层模型外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议，对应关系如下： TCP/IP协议是互联网的基础协议。 ！OSI七层模型每层作用 下面具体介绍OSI七层模型： 物理层激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。物理层确保原始数据可在各种物理媒体上传输，包含了两个重要的设备：中继器(放大器)和集线器。 数据链路层数据链路层在物理层提供的服务基础上为网络层提供服务，最基本的服务是将源自网络层的数据可靠地传输到相邻节点的目标机网络层。为了达到这一目的，数据链路层必须具备一系列的功能，主要有： 1)如何将数据组合成数据块，即帧(frame) 2)如何控制帧在物理信道上的传输 3）在两个网络实体之间提供数据链路通道的建立、维持和释放的管理 数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。 有关数据链路层的重要知识点： 1&gt; 数据链路层为网络层提供可靠的数据传输 2&gt; 基本数据单位为帧 3&gt; 主要的协议：以太网协议 4&gt; 两个重要设备名称：网桥和交换机 网络层网络层的目的是实现两个端系统之间的数据透明传送，”路径选择、路由和逻辑寻址” 1&gt; 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能； 2&gt; 基本数据单位为IP数据报； 3&gt; 包含的主要协议: IP协议（Internet Protocol，因特网互联协议） ICMP协议（Internet Control Message Protocol，因特网控制报文协议） ARP协议（Address Resolution Protocol，地址解析协议） RARP协议（Reverse Address Resolution Protocol，逆地址解析协议） 4&gt; 重要的设备：路由器 传输层第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供到端到端的、可靠的或不可靠的传输，还要处理差错控制和流量控制问题。 传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。 网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。 1&gt; 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题 2&gt; 包含的主要协议： TCP协议(Transmission Control Protocol，传输控制协议) UDP协议(User Datagram Protocol，用户数据报协议) 3&gt; 重要设备：网关 会话层会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。 表示层表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。 应用层为操作系统或网络应用程序提供访问网络服务的接口。 1&gt; 数据传送的基本单位为报文 2&gt; 包含的主要协议： FTP（文件传送协议） Telnet（远程登录协议） DNS（域名解析协议） SMTP（邮件传送协议） POP3协议（邮局协议 HTTP协议（Hyper Text Transfer Protocol） 本文链接：计算机网络基础知识总结]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-概述]]></title>
    <url>%2F2018%2F09%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[概述1.计算机网络的两大功能：连通性和共享 2.因特网发展的三个阶段： 1）从单个网络ARPANET向互联网发展的过程 2）建成了三级结构的因特网 3）逐渐形成了多层次的ISP(Internet service provider)结构的因特网 3.NAP（IXP）网络接入点：用来交换因特网上流量；向各ISP提供交换设施，使他们能够互相平等通信 4.因特网的组成： (1)边缘部分：用户利用核心部分提供的服务直接使用网络进行通信并交换或共享信息;端系统：主机，进程之间的通信 两类通信方式： 1）客户服务器方式：客户是服务的请求方，服务器是服务的提供方； 客户程序：一对多，必须知道服务器程序的地址 服务器程序：可同时处理多个远地或本地客户的请求（被动等待） 2）对等连接方式(p2p)：平等的、对等连接通信，既是通信端又是服务端 (2)核心部分：为边缘部分提供服务（提供连通性和交换），主要由路由器和网络组成；核心中的核心：路由器（转发收到的分组，实现分组交换） 交换：按照某种方式动态的分配传输线路的资源 1）电路交换：建立连接(占用通信资源)——通话（一直占用通信资源）——释放资源（归还通信资源） 2）报文交换：基于存储转发原理（时延较长） 3）分组交换：报文切割加上首部形成分组，高效、灵活、迅速、可靠 存储转发时造成时延 后两者不需要预先分配传输带宽 路由器处理分组过程：缓存–查找转发表–找到合适端口 电路交换、报文交换、分组交换的比较 1、电路交换 公共电话网(PSTN网)和移动网(包括GSM和CDMA网)采用的都是电路交换技术，它的基本特点是采用面向连接的方 式，在双方进行通信之前，需要为通信双方分配一条具有固定宽带的通信电路，通信双方在通信过程中一直占用所 分配的资源，直到通信结束，并且在电路的建立和释放过程中都需要利用相关的信令协议。这种方式的优点是在通 信过程中可以保证为用户提供足够的带宽，并且实时性强，时延小，交换设备成本低，但同时带来的缺点是信道利 用率低，一旦电路被建立不管通信双方是否处于通话状态分配的电路一直被占用。 2、报文交换 报文交换是以报文为数据交换的单位，报文携带有目标地址、源地址等信息，在交换结点采用存储转发的传输方 式；由于报文长度差异很大，长报文可能导致很大的时延；为了满足各种长度报文的需要并且达到高效的目的，节 点需要分配不同大小的缓冲区，否则就有可能造成数据传送的失败，这样对每个节点来说缓冲区的分配也比较困 难。另外一个缺点是出错时，整个报文都将重传。 3、分组交换 分组交换仍采用存储转发传输方式，但将一个长报文先分割为若干个较短的分组，然后把这些分组（携带源、目的 地址和编号信息）逐个地发送出去。采用分组交换技术，在通信之前不需要建立连接，每个节点首先将前一节点送 来的分组收下并保存在缓冲区中，然后根据分组头部中的地址信息选择适当的链路将其发送至下一个节点，这样在 通信过程中可以根据用户的要求和网络的能力来动态分配带宽。分组交换比电路交换的信道利用率高，但时延较 大。分组转发的带来的问题：排队时延以及增加头部带来的开销。 总之，若要传送的数据量很大，且其传送时间远大于呼叫时间，则采用电路交换较为合适；当端到端的通路有很多 段的链路组成时，采用分组交换传送数据较为合适。从提高整个网络的信道利用率上看，报文交换和分组交换优于 电路交换，其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式的数据通信。 5.计算机网络的分类： 按作用范围：WAN,MAN,LAN,PAN 按介质：有线网，光纤网，无限网络 按无线上网方式：WLAN,WWAN(手机） 按通信性能：资源共享，分布式计算机，远程通信网络 6.计算机网络的性能： 1）速率（比特每秒b/s）:数据量/信息量的单位 2）带宽：频域称谓，赫兹Hz，信号具有的频带宽度；时域称谓，比特每秒，通信线路的最高数据率；两者本质一样，宽度越大，传输速率自然越高 3）吞吐量：单位时间内通过某个网络（或信道、接口）的数据量 4）时延： 发送时延（传输时延）：发生在内部的发送器中 传播时延：发生在外部的传输信道媒体上 处理时延：交换结点为存储转发而进行一些处理所花费的时间 排队时延：结点缓存队列中分组排队所经历的时延（取决于当时的通信量） 数据的发送率不是比特在链路上的传播速率 5）时延带宽积 6）往返时间（RTT）：简单说就是两倍传播时延（实际上还包括处理时延，排队时延，转发时的发送时延） 7）利用率 本文链接： 1.计算机网络知识点整理 2.计算机网络知识复习重点]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法整理]]></title>
    <url>%2F2018%2F09%2F09%2FMarkdown%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[本文是对Markdown常用语法的总结。tab键相当于四个空格，每一行开始进入语法编辑状态，输入tab则进入文本编辑状态。 一.标题第一种： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ###### 五级标题 ###### 六级标题 支持h1-h6 第二种： 一级标题 ============== 二级标题 -------------- =和-的数量没有限制，大于一个即行。 第三种： # 一级标题# ## 二级标题## 支持h1-h6 二.斜体和粗体1.*斜体* 2.**粗体** 3.***加粗斜体*** 4.~~删除线~~ 显示效果： 1.斜体 2.粗体 3.加粗斜体 4.删除线 三.列表1.无序列表： * * * +，-也可以。 2.有序列表： 1.列表1 2.列表2 3.列表3 效果如下所示：1.无序列表： 2.有序列表： 1.列表1 2.列表2 3.列表3 3.定义型列表 定义型列表由名词和解释组成，一行写上定义，紧跟一行写解释。解释的语法：紧跟一个缩进（tab)。 1. Markdown 2. ： 轻量级文本标记语言，可以转换成HTML和PDF格式 3. 4. 代码块2 5. ： 这是代码块的定义 6. 7. 代码块 显示效果： Markdown 轻量级文本标记语言，可以转换成HTML和PDF格式 代码块2 这是代码块的定义 代码块 四.链接链接分为行内式和引用式。 1.行内式： 欢迎来到[Nowshi Blog](http://janicelin.com) 欢迎来到[百度](www.baidu.com) 显示效果： 欢迎来到Nowshi Blog 欢迎来到百度 2.引用式： I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [baidu][3]. [1]: http://google.com [2]: http://search.yahoo.com [3]: http://baidu.com 效果如下： I get 10 times more traffic from Google than from Yahoo or baidu. 五.引用语法说明： 引用需要在被引用的文本前加上&gt;符号。 *不以结婚为目的的谈恋爱都是耍流氓 &gt;这是毛主席说的 *有钱和情最有缘 &gt;这是我说的 效果如下： *不以结婚为目的的谈恋爱都是耍流氓 这是毛主席说的 *有钱和情最有缘 这是我说的 六.锚点网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。 Markdown Extra 只支持在标题后插入锚点，其它地方无效。 语法描述： 在你准备跳转到的指定标题后插入锚点标记，然后在文档的其它地方写上连接到锚点的链接。 七.脚注在需要添加注脚的文字后加上脚注名字[^注脚名字]称为加注。 使用Markdown[^1]可以效率的书写文档，直接转换成HTML,你可 以使用Leanote[^2]编辑器进行书写 [^1]:Markdown是一种纯文本标记语言 [^2]:开源笔记平台，支持Markdown和笔记直接发为博文 效果如下： 使用Markdown^1可以效率的书写文档，直接转换成HTML,你可 以使用Leanote^2编辑器进行书写 八.表格First Header | Second Header ------------- | ------------- Content Cell | Content Cell Content Cell | Content Cell 九.代码1.用(1234``` bash$ hexo new &quot;My New Post&quot; 效果如下： 1$ hexo new "My New Post" 2.tab缩进 第一种：简单文字出现一个代码框。使用&lt;blockquote&gt;。 （不是单引号而是左上角的ESC下面~中的） 第二种：大片文字需要实现代码框。使用Tab和四个空格。 十.图片插入图片和链接类似，分为行内式和引用式。 1.行内式： 语法说明： ![图片alt](图片地址 &quot;图片title&quot;) 美丽花儿： ！[美丽花儿](http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg &quot;美丽花儿&quot;) 显示效果： 美丽花儿： 美丽花儿 2.引用式 语法说明： ！[图片alt][标记] [标记]：图片地址 &quot;title&quot; 美丽花儿： [美丽花儿][flower] [flower]:http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg &quot;美丽花儿&quot; 显示效果： 美丽花儿： 美丽花儿 十一.视频Markdown语法不支持插入视频 普遍的做法是插入HTML的ifame框架，通过网站自带的分享功能获取 第二种做法是伪造播放界面，实质是插入视频图片，然后通过点击跳转到相关页面 本文链接： 1..md即markdown文件的基本常用编写语法（图文并茂) 2.Markdown 语法整理大集合2017 3.Markdown 11种基本语法 4.Markdown 语法手册(完整整理版)]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web学习之旅开始]]></title>
    <url>%2F2018%2F09%2F08%2Fwen%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[This is the beginning.]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo github 部署个人博客]]></title>
    <url>%2F2018%2F08%2F14%2Fhexo-github-pages-blog%2F</url>
    <content type="text"><![CDATA[hexo+github pages搭建个人博客1.环境准备：win10git node.js npm github 2.域名域名解析 添加记录：192.30.252.153 192.30.252.154 两个A记录 http://shihaitao123.github.io www.janicelin.com 3.建站过程一.安装Hexo npm install -g hexo-cli 二.建立站点 三.配置站点 config.yml文件内 四.生成内容 五.主题 主题安装和渲染 4.部署到GitHub终端下的目录文件夹中完成 1.create a reposity 2.set up git user.name和Email 3.身份验证 生成SSH key添加到GitHub账户 4.测试连接 5.hexo部署1.deploy: type: git repo: https://github.com/your_name/ your_name.github.io.git（2.0版本，更改） branch: master 2.hexo clean hexo g hexo s hexo d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test for Hexo]]></title>
    <url>%2F2018%2F08%2F14%2Ftest%2F</url>
    <content type="text"><![CDATA[This is the first test for hexo.]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
